

## 软件测试的原则

> 1. 用例必须包含预期结果
> 2. 编写程序的团队或个人都应该避免测试(验收测试)自己编写的程序
> 3. 彻底检查每个测试结果
> 4. 测试用例应当包含有效输入和无效输入
> 5. 检查程序是否做了“应该做的”动作，和“不应该做的”动作
> 6. 保存用例，用以回归
> 7. 测试前不应该假定程序没有错误
> 8. 程序某部分已发现的问题更多，该部分存在更多错误的可能可能性越大
> 9. 通过测试消灭所有bug是不可能。如何使用更少的成本找出更多的bug，这是软件测试根本性的挑战

![Bug的聚集原理](https://s2.ax1x.com/2019/10/18/KZ3F0O.png)
## 人工测试
1. **代码检查(Code Review)**
    *条件*： 3-4人，1-2小时，150行代码/hour，一个常见错误检查列表，一个协调员，一个代码作者，一个测试专家
    *限制*：程序员不可自我审查，对事不对人，错误列表应聚焦于错误而不是需求和代码风格
    *过程*：
     	1) 协调员 => 安排进程、准备材料
     	2) 代码作者 => 大声地 逐条讲解程序的逻辑结构
     	3) 所有人 => 尝试发现错误
     	3) 协调员 => 确保所有人集中精力发现错误，而不是尝试修复
     	4) 协调员 => 记录所有错误
     	5) 代码作者 => 修复所有错误
	*好处*：发现错误，发现容易出错的地方，提供编程风格、技术上的反馈，有利于高效开发模式的形成(没有人身攻击的情况下)
	*参考错误列表*：
	![错误列表1](https://s2.ax1x.com/2019/10/11/uHTO81.png)
    ![错误列表2](https://s2.ax1x.com/2019/10/11/uHTXgx.png)

2. **代码走查**
	*条件*： 3-5人，1-2小时，150行代码/hour，一个协调员，一个代码作者，一个测试员，一个秘书，一份少量且结构简单的测试用例
	*限制*：对事不对人，错误列表应聚焦于错误而不是需求和代码风格
	*过程*：
     	1) 协调员 => 提前2～3天分发材料
     	2) 测试员 => 提前准备一份测试用例，少量且结构简单，用于在走查时启动思路
     	3) 所有人 => 走查时，所有人在脑中执行测试用例，用纸张或白板记录程序的状态，检查程序的逻辑，向程序员提问
     	4) 秘书 => 记录所有发现的问题
     	6) 代码作者 => 修复问题
	*好处*：发现错误，发现容易出错的地方，提供编程风格、技术上的反馈，有利于高效开发模式的形成(没有人身攻击的情况下)

3. **桌面检查**
    *条件*： 1人，1-2小时，150行代码/hour，一个常见错误检查列表
    *过程*：检查者通过对照错误列表检查程序，对程序进行推演测试数据

4. **同行评审**
    *条件*： 6~20人，2小时，一个管理员，一个评价表模板
    *限制*：参与人员的技术背景相同，每个参与者提交2个自己的程序(一个自认较好，一个自认较坏)，匿名评审
    *过程*：
        	1) 管理员 => 收集所有人的程序，随机分发给参与者，每人4个，其中2个“较好“，2个”较差“
        	2) 参与者 => 阅读并评审程序，一个程序评审30min，每个程序阅读完成后填写一张评价表，提交给管理员
        	3) 管理员 => 统计每个程序在所有程序中的整体和具体(分项目)得分情况
        	4) 参与者 => 收到自己程序的评价表 和 自己程序在所有程序中的整体和具体(分项目)得分情况的统计结果(只有自己的名字)

    参考评审表：
    每个问题10分，10为明确肯定，1为明确否定
    ![参考评审表](https://s2.ax1x.com/2019/10/11/ubMZ4S.png)

## 测试用例的设计
设计测试用例的**最大难题**在于：在所有可能的测试用例中，哪个子集最有可能发现**最多、最严重**的错误。

1. **白盒测试**
	- 语句覆盖
	- 判定覆盖
	- 条件覆盖
	- 判定/条件覆盖
	- 多重条件覆盖
2. **黑盒测试**
	- 等价类划分
	- 边界值分析
	- 因果图分析
	- 错误猜测
3. **错误猜测**

4. **测试策略**




## 杂项
1. MTTR：Mean Time To Repair， 平均恢复时间
2. MTBF：Mean Time Between Failure，平均故障间隔时间